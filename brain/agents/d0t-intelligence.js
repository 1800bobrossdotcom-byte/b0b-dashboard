#!/usr/bin/env node
/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 *  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—    â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—     
 *  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â•šâ•â•â–ˆâ–ˆâ•”â•â•â•    â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘     
 *  â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘       â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘     
 *  â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘       â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘     
 *  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•   â–ˆâ–ˆâ•‘       â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
 *  â•šâ•â•â•â•â•â•  â•šâ•â•â•â•â•â•    â•šâ•â•       â•šâ•â•â•šâ•â•  â•šâ•â•â•â•   â•šâ•â•   â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•
 * 
 *  d0t Trading Intelligence â€” Tegmark L2 Focus (Emergent Dynamics)
 * 
 *  Core Philosophy:
 *  - NOT just parroting external APIs
 *  - Multi-dimensional classification (Nash + Entropy + Fractals)
 *  - Library-informed pattern detection
 *  - L0RE lexicon vocabulary
 * 
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

const { L0REIntelligence, NASH_STATES, FRACTAL_PATTERNS } = require('../l0re-intelligence.js');

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// d0t SPECIFIC CLASSIFICATIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const D0T_MARKET_STATES = {
  // Beyond simple fear/greed â€” multi-dimensional states
  
  TURB0_ACCUMULATION: {
    code: 'd.t4cc',
    description: 'High fear + low volatility + smart money entering',
    action: 'TURB0B00ST position building',
    emoji: 'ğŸš€â¬†ï¸',
    conditions: (data) => 
      data.sentiment < 25 && 
      data.volatility < 0.3 && 
      data.onchainChange >= 0,
  },
  
  DIAMOND_HANDS: {
    code: 'd.d1hd',
    description: 'Fear + holding strong + conviction',
    action: 'Hold position, accumulate on dips',
    emoji: 'ğŸ’ğŸ™Œ',
    conditions: (data) =>
      data.sentiment < 40 &&
      data.volumeChange < -20 &&
      data.narrativeStrength > 0.5,
  },
  
  ESCAPE_VELOCITY: {
    code: 'd.3scv',
    description: 'Breaking out of equilibrium, momentum building',
    action: 'Ride momentum, trailing stops',
    emoji: 'ğŸš€ğŸŒ™',
    conditions: (data) =>
      data.momentum > 0.4 &&
      data.trend === 'up' &&
      data.entropyLow,
  },
  
  DISTRIBUTION_ALERT: {
    code: 'd.d5tr',
    description: 'Greed + smart money exiting + divergence',
    action: 'Take profits, reduce exposure',
    emoji: 'âš ï¸ğŸ“‰',
    conditions: (data) =>
      data.sentiment > 70 &&
      data.onchainChange < -3 &&
      data.volumeChange > 20,
  },
  
  CAPITULATION_ZONE: {
    code: 'd.c4pt',
    description: 'High fear + high volatility + cascade selling',
    action: 'Wait for stabilization before entry',
    emoji: 'ğŸ©¸ğŸ“‰',
    conditions: (data) =>
      data.sentiment < 15 &&
      data.volatility > 0.7 &&
      data.onchainChange < -10,
  },
  
  SCHELLING_CONVERGENCE: {
    code: 'd.schl',
    description: 'Narrative coordination, meme power',
    action: 'Align with narrative momentum',
    emoji: 'ğŸ¯âœ¨',
    conditions: (data) =>
      data.memeVelocity > 0.6 ||
      data.viralNarrative === true,
  },
  
  EQUILIBRIUM_HARVEST: {
    code: 'd.3qhr',
    description: 'Stable range, yield opportunities',
    action: 'Range trading, provide liquidity',
    emoji: 'ğŸŒ¾ğŸ“Š',
    conditions: (data) =>
      data.volatility < 0.2 &&
      Math.abs(data.sentiment - 50) < 15 &&
      data.trend === 'sideways',
  },
  
  ENTROPY_CHAOS: {
    code: 'd.3nch',
    description: 'Maximum uncertainty, regime change',
    action: 'Reduce exposure, increase cash',
    emoji: 'ğŸŒ€â“',
    conditions: (data) =>
      data.entropy > 0.7,
  },
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// d0t INTELLIGENCE CLASS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class D0TIntelligence {
  constructor() {
    this.l0re = new L0REIntelligence();
    this.agent = this.l0re.agents.d0t;
  }

  /**
   * Classify market state â€” NOT just parroting Fear & Greed API
   */
  classify(rawData) {
    // Get base L0RE intelligence
    const l0reState = this.l0re.analyze(rawData);
    
    // Prepare normalized data for condition checks
    const data = this.normalizeData(rawData, l0reState);
    
    // Find matching d0t-specific state
    let matchedState = null;
    let matchConfidence = 0;
    
    for (const [key, state] of Object.entries(D0T_MARKET_STATES)) {
      try {
        if (state.conditions(data)) {
          matchedState = { key, ...state };
          matchConfidence = 0.7;
          break;
        }
      } catch (e) {}
    }
    
    // Default fallback based on L0RE composite
    if (!matchedState) {
      matchedState = this.fallbackClassification(l0reState, data);
    }
    
    return {
      // d0t specific classification
      d0t: {
        state: matchedState.key,
        code: matchedState.code,
        description: matchedState.description,
        action: matchedState.action,
        emoji: matchedState.emoji,
        confidence: matchConfidence,
      },
      
      // L0RE multi-dimensional state
      l0re: {
        code: l0reState.l0reCode,
        nash: l0reState.nash.state,
        entropy: l0reState.entropy.classification,
        fractal: l0reState.fractal.pattern,
        composite: l0reState.composite,
      },
      
      // Trading signals
      signals: this.generateSignals(l0reState, matchedState, data),
      
      // Agent action from L0RE
      agentAction: l0reState.agentActions.d0t,
      
      // Raw normalized data
      data,
    };
  }

  normalizeData(rawData, l0reState) {
    return {
      // Sentiment â€” NOT just parroting the API
      sentiment: rawData.sentiment?.index || 50,
      sentimentRaw: rawData.sentiment?.classification || 'Neutral',
      
      // Volatility estimate
      volatility: l0reState.tegmark.L1.volatility,
      
      // Entropy (Shannon)
      entropy: l0reState.entropy.value,
      entropyLow: l0reState.entropy.value < 0.3,
      entropyHigh: l0reState.entropy.value > 0.7,
      
      // Trend and momentum (Tegmark L2)
      trend: l0reState.tegmark.L2.trend,
      momentum: l0reState.tegmark.L2.momentum,
      regime: l0reState.tegmark.L2.regime,
      
      // On-chain
      onchainChange: rawData.onchain?.base_change_1d || 0,
      baseTVL: rawData.onchain?.base_tvl || 0,
      ethTVL: rawData.onchain?.eth_tvl || 0,
      
      // Narrative (Tegmark L3)
      narrativeStrength: l0reState.tegmark.L3.narrativeStrength,
      memeVelocity: l0reState.tegmark.L3.memeVelocity,
      
      // Volume
      volumeChange: rawData.volumeChange || 0,
      
      // Viral detection
      viralNarrative: rawData.viralNarrative || false,
    };
  }

  fallbackClassification(l0reState, data) {
    // Use Nash state as primary fallback
    const nashAction = NASH_STATES[l0reState.nash.state];
    
    switch (l0reState.nash.state) {
      case 'COOPERATIVE':
        return {
          key: 'TURB0_ACCUMULATION',
          code: 'd.n4co',
          description: 'Nash Cooperative â€” positive sum game',
          action: nashAction.action,
          emoji: 'ğŸ¤ğŸ“ˆ',
        };
      case 'DEFECTION':
        return {
          key: 'CAPITULATION_ZONE',
          code: 'd.n4df',
          description: 'Nash Defection â€” exit liquidity',
          action: nashAction.action,
          emoji: 'ğŸƒğŸ’¨',
        };
      case 'SCHELLING':
        return {
          key: 'SCHELLING_CONVERGENCE',
          code: 'd.n4sc',
          description: 'Nash Schelling Point â€” coordination',
          action: nashAction.action,
          emoji: 'ğŸ¯ğŸ¯',
        };
      default:
        return {
          key: 'EQUILIBRIUM_HARVEST',
          code: 'd.n4eq',
          description: 'Nash Equilibrium â€” stable state',
          action: nashAction.action,
          emoji: 'âš–ï¸ğŸ“Š',
        };
    }
  }

  generateSignals(l0reState, matchedState, data) {
    const signals = [];
    
    // PRIMARY SIGNAL â€” from d0t classification
    signals.push({
      type: 'PRIMARY',
      source: 'd0t',
      signal: matchedState.action,
      confidence: 0.7,
    });
    
    // NASH SIGNAL â€” game theory
    signals.push({
      type: 'NASH',
      source: 'l0re',
      signal: l0reState.nash.action,
      state: l0reState.nash.state,
      confidence: l0reState.nash.confidence,
    });
    
    // FRACTAL SIGNAL â€” pattern recognition
    signals.push({
      type: 'FRACTAL',
      source: 'l0re',
      signal: this.fractalToSignal(l0reState.fractal.pattern),
      pattern: l0reState.fractal.pattern,
      confidence: FRACTAL_PATTERNS[l0reState.fractal.pattern].confidence_boost + 0.5,
    });
    
    // ENTROPY SIGNAL â€” information theory
    if (data.entropyHigh) {
      signals.push({
        type: 'ENTROPY_WARNING',
        source: 'l0re',
        signal: 'HIGH UNCERTAINTY â€” reduce position size',
        confidence: 0.8,
      });
    }
    
    // COMPOSITE SIGNAL
    signals.push({
      type: 'COMPOSITE',
      source: 'l0re',
      signal: l0reState.composite.signal,
      score: l0reState.composite.score,
      confidence: l0reState.composite.confidence,
    });
    
    return signals;
  }

  fractalToSignal(pattern) {
    const signals = {
      ACCUMULATION: 'Smart money entering â€” consider building position',
      DISTRIBUTION: 'Smart money exiting â€” consider taking profits',
      MARKUP: 'Trend established â€” ride momentum with stops',
      MARKDOWN: 'Downtrend â€” wait for reversal signals',
      RANGING: 'Consolidation â€” range trade or wait for breakout',
    };
    return signals[pattern] || 'Monitor';
  }

  /**
   * Generate TURB0B00ST trading decision
   */
  turb0Decision(rawData) {
    const analysis = this.classify(rawData);
    
    // Count bullish vs bearish signals
    let bullish = 0;
    let bearish = 0;
    
    for (const signal of analysis.signals) {
      if (signal.signal.toLowerCase().includes('accumulat') || 
          signal.signal.toLowerCase().includes('build') ||
          signal.signal.toLowerCase().includes('enter') ||
          signal.signal.toLowerCase().includes('ride')) {
        bullish += signal.confidence;
      }
      if (signal.signal.toLowerCase().includes('exit') ||
          signal.signal.toLowerCase().includes('reduce') ||
          signal.signal.toLowerCase().includes('profit') ||
          signal.signal.toLowerCase().includes('wait')) {
        bearish += signal.confidence;
      }
    }
    
    const netSignal = bullish - bearish;
    
    let decision = 'HOLD';
    let size = 0;
    
    if (netSignal > 1.5) {
      decision = 'TURB0_BUY';
      size = Math.min(1, netSignal / 3);
    } else if (netSignal > 0.5) {
      decision = 'BUY';
      size = 0.3;
    } else if (netSignal < -1.5) {
      decision = 'TURB0_SELL';
      size = Math.min(1, Math.abs(netSignal) / 3);
    } else if (netSignal < -0.5) {
      decision = 'SELL';
      size = 0.3;
    }
    
    return {
      decision,
      size,
      bullishScore: bullish,
      bearishScore: bearish,
      netSignal,
      analysis,
    };
  }
}

module.exports = { D0TIntelligence, D0T_MARKET_STATES };

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CLI
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if (require.main === module) {
  const intel = new D0TIntelligence();
  
  // Test with current market data
  const testData = {
    sentiment: null,
    onchain: { base_tvl: 4544725508, base_change_1d: 0, eth_tvl: 66030137367 },
    volumeChange: -15,
  };
  
  const result = intel.classify(testData);
  
  console.log(`
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  d0t TRADING INTELLIGENCE â€” Multi-Dimensional Analysis                        â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  State: ${result.d0t.emoji} ${result.d0t.state.padEnd(25)}                              â•‘
â•‘  Code: ${result.d0t.code}                                                          â•‘
â•‘  Action: ${result.d0t.action.slice(0, 50).padEnd(50)}         â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  L0RE: ${result.l0re.code.padEnd(30)}                                       â•‘
â•‘  Nash: ${result.l0re.nash.padEnd(15)} â”‚ Entropy: ${result.l0re.entropy.padEnd(10)} â”‚ Fractal: ${result.l0re.fractal.padEnd(12)} â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  SIGNALS:                                                                       â•‘`);

  for (const signal of result.signals) {
    console.log(`â•‘  [${signal.type.slice(0, 8).padEnd(8)}] ${signal.signal.slice(0, 50).padEnd(50)}     â•‘`);
  }
  
  console.log(`â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  `);
  
  // TURB0 decision
  const turb0 = intel.turb0Decision(testData);
  console.log(`TURB0 Decision: ${turb0.decision} (size: ${turb0.size.toFixed(2)}, net: ${turb0.netSignal.toFixed(2)})`);
}

